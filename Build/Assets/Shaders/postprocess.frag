#version 430

#define GRAYSCALE	(1 << 0)
#define COLORTINT	(1 << 1)
#define SCANLINE	(1 << 2)
#define GRAIN		(1 << 3)
#define INVERT		(1 << 4)
#define OUTLINE     (1 << 5)

in vec2 v_texcoord;

out vec4 f_color;

// post process controls
uniform uint u_parameters = 0;
uniform vec3 u_colorTint = vec3(1, 1, 1);

uniform float u_time = 0;	// used in random function
uniform float u_blend = 0;  // blend between original and postprocess color

uniform sampler2D u_baseMap;

// There is no random function in GLSL, uses math function to generate psuedo random number
// https://thebookofshaders.com/10/
float random(vec2 st) 
{
	return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

void main()
{
	vec4 color = texture(u_baseMap, v_texcoord);
	vec4 postprocess = color;

	// perceptually-weighted grayscale
	if ((u_parameters & GRAYSCALE) != 0u)
	{
		float lum = dot(postprocess.rgb, vec3(0.299, 0.587, 0.114));
		postprocess.rgb = vec3(lum);
	}

	if ((u_parameters & COLORTINT) != 0u)
		postprocess.rgb *= u_colorTint;

	// preserve alpha and only affect RGB; use periodic scanlines every 3 pixels
	if ((u_parameters & SCANLINE) != 0u)
	{
		float line = (mod(floor(gl_FragCoord.y), 3.0) == 0.0) ? 1.0 : 0.0;
		postprocess.rgb *= line;
	}

	// subtle grain/noise applied to RGB only
	if ((u_parameters & GRAIN) != 0u)
	{
		float n = random(gl_FragCoord.xy + u_time);
		// small amplitude noise centered at 0
		postprocess.rgb += (n - 0.5) * 0.08;
	}

	// invert RGB only, preserve alpha
	if ((u_parameters & INVERT) != 0u)
		postprocess.rgb = 1.0 - postprocess.rgb;

		//the following code was generated by chatgpt as I had no idea how to implement this but I came up with the idea on my own
		//https://chatgpt.com/share/6925f50c-5c40-8013-90de-6418067f0d63
		if ((u_parameters & OUTLINE) != 0u)
{
    vec2 texel = 1.0 / textureSize(u_baseMap, 0);

    // sample 3x3 neighbourhood
    vec3 tl = texture(u_baseMap, v_texcoord + texel * vec2(-1,-1)).rgb;
    vec3 tc = texture(u_baseMap, v_texcoord + texel * vec2( 0,-1)).rgb;
    vec3 tr = texture(u_baseMap, v_texcoord + texel * vec2( 1,-1)).rgb;

    vec3 ml = texture(u_baseMap, v_texcoord + texel * vec2(-1, 0)).rgb;
    vec3 mc = texture(u_baseMap, v_texcoord            ).rgb;
    vec3 mr = texture(u_baseMap, v_texcoord + texel * vec2( 1, 0)).rgb;

    vec3 bl = texture(u_baseMap, v_texcoord + texel * vec2(-1, 1)).rgb;
    vec3 bc = texture(u_baseMap, v_texcoord + texel * vec2( 0, 1)).rgb;
    vec3 br = texture(u_baseMap, v_texcoord + texel * vec2( 1, 1)).rgb;

    // Sobel filter for edges
    vec3 sx = tl + 2.0*ml + bl - tr - 2.0*mr - br;
    vec3 sy = tl + 2.0*tc + tr - bl - 2.0*bc - br;

    float edge = length(sx) + length(sy);

    // threshold to produce a binary outline
    float outline = edge > 0.2 ? 1.0 : 0.0;

    // output ONLY the outline (white) on black background
    postprocess = vec4(vec3(outline), 1.0);
}

	f_color = mix(color, postprocess, u_blend); // mix colors using u_blend (0-1)
}